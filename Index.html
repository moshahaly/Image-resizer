<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Image Resizer Pro</title>
    <meta name="theme-color" content="#6366f1">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --secondary: #a855f7;
            --background: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --error: #ef4444;
            --primary-gradient: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background: #0f172a;
                --card-bg: #1e293b;
                --text: #f8fafc;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', system-ui, sans-serif;
        }

        body {
            min-height: 100vh;
            background: var(--background);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .upload-controls {
            position: relative;
            margin: 2rem 0;
            text-align: center;
        }

        .modern-button {
            background: var(--primary-gradient);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            transition: transform 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .modern-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .modern-button input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-count {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .quality-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .preview-card {
            background: var(--card-bg);
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .preview-image {
            width: 100%;
            height: 200px;
            object-fit: contain;
            border-radius: 0.5rem;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--error);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Ultimate Image Resizer Pro</h1>
            <p>Advanced Image Processing PWA</p>
        </div>

        <div class="upload-controls">
            <button id="uploadButton" class="modern-button">
                üìÅ Upload Images
                <input type="file" id="fileInput" accept="image/*" multiple hidden>
            </button>
            <div class="file-count" id="fileCount">0 files selected</div>
        </div>

        <div class="controls">
            <div>
                <input type="number" id="widthInput" placeholder="Width (px)" min="1">
                <input type="number" id="heightInput" placeholder="Height (px)" min="1">
            </div>
            <div class="quality-controls">
                <input type="range" id="qualityInput" min="0" max="1" step="0.1" value="0.9">
                <span>Quality: <span id="qualityValue">90%</span></span>
            </div>
            <div>
                <button class="modern-button" id="resizeButton">Resize Selected</button>
                <button class="modern-button" id="batchButton">Process Batch</button>
            </div>
        </div>

        <div class="preview-grid" id="previewGrid"></div>
        <div class="loading" id="loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Processing...</p>
        </div>
    </div>

    <script>
        class ImageProcessor {
            constructor() {
                this.files = [];
                this.queue = [];
                this.processing = false;
            }

            async addFiles(files) {
                const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'];
                const validFiles = Array.from(files).filter(file => 
                    validTypes.includes(file.type)
                );
                
                if (validFiles.length === 0) {
                    throw new Error('No valid image files selected');
                }

                this.files = [...this.files, ...validFiles];
                return validFiles;
            }

            async processAll() {
                if (this.processing) return;
                this.processing = true;
                
                try {
                    const zip = new JSZip();
                    
                    for (const [index, file] of this.files.entries()) {
                        const processed = await this.processFile(file);
                        zip.file(`resized-${index}-${file.name}`, processed.blob);
                    }

                    const content = await zip.generateAsync({type: 'blob'});
                    this.downloadFile(content, 'resized-images.zip');
                } catch (error) {
                    this.showError(error.message);
                } finally {
                    this.processing = false;
                }
            }

            async processFile(file) {
                return new Promise(async (resolve, reject) => {
                    try {
                        const img = await this.loadImage(file);
                        const canvas = this.createCanvas(img);
                        const orientation = await this.getExifOrientation(file);
                        this.applyOrientation(canvas, orientation);
                        
                        const blob = await new Promise(resolve => 
                            canvas.toBlob(resolve, file.type, parseFloat(qualityInput.value))
                        );

                        resolve({ blob, url: URL.createObjectURL(blob) });
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            async getExifOrientation(file) {
                return new Promise(resolve => {
                    EXIF.getData(file, function() {
                        resolve(EXIF.getTag(this, 'Orientation') || 1);
                    });
                });
            }

            applyOrientation(canvas, orientation) {
                const ctx = canvas.getContext('2d');
                ctx.save();
                
                switch(orientation) {
                    case 2: ctx.transform(-1, 0, 0, 1, canvas.width, 0); break;
                    case 3: ctx.transform(-1, 0, 0, -1, canvas.width, canvas.height); break;
                    case 4: ctx.transform(1, 0, 0, -1, 0, canvas.height); break;
                    case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;
                    case 6: ctx.transform(0, 1, -1, 0, canvas.height, 0); break;
                    case 7: ctx.transform(0, -1, -1, 0, canvas.height, canvas.width); break;
                    case 8: ctx.transform(0, -1, 1, 0, 0, canvas.width); break;
                }
                
                ctx.restore();
            }

            downloadFile(blob, filename) {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }

            showError(message) {
                const errorEl = document.createElement('div');
                errorEl.className = 'error-message';
                errorEl.textContent = message;
                document.body.appendChild(errorEl);
                setTimeout(() => errorEl.remove(), 5000);
            }
        }

        class UIController {
            constructor(imageProcessor) {
                this.imageProcessor = imageProcessor;
                this.initialize();
            }

            initialize() {
                this.initializeUpload();
                this.initializeControls();
                this.initializeQualitySlider();
            }

            initializeUpload() {
                const fileInput = document.getElementById('fileInput');
                const fileCount = document.getElementById('fileCount');
                const previewGrid = document.getElementById('previewGrid');

                fileInput.addEventListener('change', async (e) => {
                    try {
                        const files = Array.from(e.target.files);
                        const validFiles = await this.imageProcessor.addFiles(files);
                        fileCount.textContent = `${validFiles.length} files selected`;
                        this.updatePreviewGrid(validFiles);
                    } catch (error) {
                        this.showError(error.message);
                    }
                });

                const dropZone = document.getElementById('uploadButton');
                dropZone.addEventListener('dragover', (e) => e.preventDefault());
                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    try {
                        const files = Array.from(e.dataTransfer.files);
                        const validFiles = await this.imageProcessor.addFiles(files);
                        fileCount.textContent = `${validFiles.length} files selected`;
                        this.updatePreviewGrid(validFiles);
                    } catch (error) {
                        this.showError(error.message);
                    }
                });
            }

            updatePreviewGrid(files) {
                const previewGrid = document.getElementById('previewGrid');
                previewGrid.innerHTML = '';
                
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const card = document.createElement('div');
                        card.className = 'preview-card';
                        card.innerHTML = `
                            <img src="${e.target.result}" class="preview-image" alt="Preview">
                            <div>${file.name}</div>
                        `;
                        previewGrid.appendChild(card);
                    };
                    reader.readAsDataURL(file);
                });
            }

            initializeControls() {
                const resizeButton = document.getElementById('resizeButton');
                const batchButton = document.getElementById('batchButton');
                const loading = document.getElementById('loading');

                resizeButton.addEventListener('click', async () => {
                    // Implement single image processing
                });

                batchButton.addEventListener('click', async () => {
                    loading.style.display = 'flex';
                    try {
                        await this.imageProcessor.processAll();
                    } catch (error) {
                        this.showError(error.message);
                    } finally {
                        loading.style.display = 'none';
                    }
                });
            }

            initializeQualitySlider() {
                const qualityInput = document.getElementById('qualityInput');
                const qualityValue = document.getElementById('qualityValue');
                qualityInput.addEventListener('input', () => {
                    qualityValue.textContent = `${Math.round(qualityInput.value * 100)}%`;
                });
            }

            showError(message) {
                this.imageProcessor.showError(message);
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            const imageProcessor = new ImageProcessor();
            new UIController(imageProcessor);
            
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(() => console.log('Service Worker registered'))
                    .catch(err => console.error('SW registration failed:', err));
            }
        });
    </script>
</body>
</html>
